import os
import glob
import re
from PIL import Image, ImageFont, ImageDraw

# Configuration
FONT_PATH = "/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc"
# Fallback to Medium if Regular doesn't exist, or just auto-detect
if not os.path.exists(FONT_PATH):
    FONT_PATH = "/usr/share/fonts/noto-cjk/NotoSansCJK-Medium.ttc"

OUTPUT_FILE = "font_zh.py"
FONT_SIZE = 16  # 16x16 pixels

def get_chinese_chars(directory="."):
    """Scans all .py files for Chinese characters."""
    chinese_chars = set()
    # Range for common CJK Unified Ideographs
    pattern = re.compile(r'[\u4e00-\u9fff]')
    
    files = glob.glob(os.path.join(directory, "*.py"))
    for fpath in files:
        if fpath.endswith(OUTPUT_FILE) or fpath.endswith("compile_font.py"):
            continue
            
        with open(fpath, 'r', encoding='utf-8') as f:
            content = f.read()
            found = pattern.findall(content)
            chinese_chars.update(found)
            
    return sorted(list(chinese_chars))

def render_char_bitmap(font, char):
    """Renders a character to a bit bytearray."""
    # Create a blank image (white on black, 1-bit)
    image = Image.new("1", (FONT_SIZE, FONT_SIZE), 0)
    draw = ImageDraw.Draw(image)
    
    # Draw text centered (or top-left depending on font metrics)
    # Noto CJK usually needs a small offset to align well in 16x16
    draw.text((0, -2), char, font=font, fill=1)
    
    # Extract bytes
    # Framebuf MONO_HLSB: Each byte is 8 horizontal pixels. 
    # Row 0: Byte 0 (Px 0-7), Byte 1 (Px 8-15)
    pixels = image.load()
    buffer = bytearray()
    
    for y in range(FONT_SIZE):
        byte_val = 0
        for x in range(0, 8):
            if pixels[x, y]:
                byte_val |= (1 << (7 - x))
        buffer.append(byte_val)
        
        byte_val = 0
        for x in range(8, 16):
            if pixels[x, y]:
                byte_val |= (1 << (15 - x)) # Fix: 15-x to map 8->7, 9->6... 
                # Wait, x is 8..15. 
                # bit 7 is pixel 8. bit 0 is pixel 15.
                # So shift is 7 - (x - 8) = 15 - x. Correct.
        buffer.append(byte_val)
        
    return buffer

def generate_font_file(chars):
    print(f"Generating {OUTPUT_FILE} with {len(chars)} characters: {''.join(chars)}")
    
    try:
        font = ImageFont.truetype(FONT_PATH, FONT_SIZE)
    except IOError:
        print(f"Error: Could not load font at {FONT_PATH}")
        return

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("# Auto-generated by compile_font.py\n")
        f.write("import framebuf\n\n")
        f.write("BITMAPS = {\n")
        
        for char in chars:
            bitmap = render_char_bitmap(font, char)
            # Format as python bytearray string
            hex_str = "".join(f"\\x{b:02x}" for b in bitmap)
            f.write(f'    "{char}": bytearray(b"{hex_str}"),\n')
            
        f.write("}\n\n")
        
        # Add the draw functions
        f.write("\ndef draw_char(fb, char, x, y):\n    if char not in BITMAPS: return\n    data = BITMAPS[char]\n    char_fb = framebuf.FrameBuffer(data, 16, 16, framebuf.MONO_HLSB)\n    fb.blit(char_fb, x, y)\n\ndef draw_text(fb, text, x, y):\n    cursor = x\n    for char in text:\n        if char in BITMAPS:\n            draw_char(fb, char, cursor, y)\n            cursor += 16\n        else:\n            cursor += 8\n")

if __name__ == "__main__":
    chars = get_chinese_chars()
    if chars:
        generate_font_file(chars)
    else:
        print("No Chinese characters found in .py files.")
